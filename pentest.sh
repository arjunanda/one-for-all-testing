#!/bin/bash

# =============================================================================
# Web Penetration Testing Script with Report Generator
# Author: Security Tester
# Version: 1.0
# =============================================================================

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variables
TARGET=""
OUTPUT_DIR=""
REPORT_FILE=""
DATE=$(date '+%Y-%m-%d_%H-%M-%S')
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Check if virtual environment is activated
check_venv() {
    if [[ -z "$VIRTUAL_ENV" ]]; then
        echo -e "${YELLOW}[INFO] Checking for virtual environment...${NC}"
        if [[ -f "$SCRIPT_DIR/pentest-venv/bin/activate" ]]; then
            echo -e "${YELLOW}[INFO] Activating virtual environment...${NC}"
            source "$SCRIPT_DIR/pentest-venv/bin/activate"
        elif [[ -f "$SCRIPT_DIR/activate_pentest.sh" ]]; then
            echo -e "${YELLOW}[INFO] Using activation script...${NC}"
            source "$SCRIPT_DIR/activate_pentest.sh"
        else
            echo -e "${YELLOW}[WARNING] Virtual environment not found. Some Python tools may not work.${NC}"
        fi
    fi
}

# Banner
show_banner() {
    echo -e "${PURPLE}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    WEB PENTEST SCANNER                       â•‘"
    echo "â•‘                  Automated Security Testing                  â•‘"
    echo "â•‘                        Version 1.0                          â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Help function
show_help() {
    echo -e "${CYAN}Usage: $0 [OPTIONS]${NC}"
    echo ""
    echo "Options:"
    echo "  -t, --target URL    Target URL to test (required)"
    echo "  -o, --output DIR    Output directory (default: pentest_results)"
    echo "  -h, --help          Show this help message"
    echo ""
    echo "Example:"
    echo "  $0 -t https://example.com -o results"
}

# Check if required tools are installed
check_dependencies() {
    echo -e "${YELLOW}[INFO] Checking dependencies...${NC}"
    
    local core_deps=("curl" "wget")
    local optional_deps=("nmap" "dig" "whois" "nikto" "dirb" "gobuster" "sqlmap" "subfinder" "httpx")
    local missing_deps=()
    local missing_optional=()
    
    # Check core dependencies (absolutely required)
    for dep in "${core_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done
    
    # Check optional dependencies
    for dep in "${optional_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_optional+=("$dep")
        fi
    done
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo -e "${RED}[ERROR] Missing critical dependencies: ${missing_deps[*]}${NC}"
        echo "Please install curl and wget first."
        exit 1
    fi
    
    if [ ${#missing_optional[@]} -ne 0 ]; then
        echo -e "${YELLOW}[WARNING] Missing optional tools: ${missing_optional[*]}${NC}"
        echo "Will use alternative methods and available tools."
    fi
    
    echo -e "${GREEN}[SUCCESS] Core dependencies found, proceeding with available tools${NC}"
    
    # Show what's available
    echo -e "${BLUE}Available tools:${NC}"
    command -v nmap >/dev/null 2>&1 && echo "âœ… nmap" || echo "âŒ nmap (will use alternative port scanning)"
    command -v dig >/dev/null 2>&1 && echo "âœ… dig" || echo "âŒ dig (will use nslookup/host)"  
    command -v whois >/dev/null 2>&1 && echo "âœ… whois" || echo "âŒ whois (will skip whois info)"
    command -v nikto >/dev/null 2>&1 && echo "âœ… nikto" || echo "âŒ nikto (will use manual checks)"
}

# Initialize output directory and report file
init_output() {
    OUTPUT_DIR="${1:-pentest_results}_${DATE}"
    mkdir -p "$OUTPUT_DIR"
    REPORT_FILE="$OUTPUT_DIR/pentest_report_${DATE}.md"
    
    echo -e "${GREEN}[INFO] Output directory: $OUTPUT_DIR${NC}"
    echo -e "${GREEN}[INFO] Report file: $REPORT_FILE${NC}"
    
    # Initialize report file
    cat > "$REPORT_FILE" << EOF
# Penetration Testing Report

**Target:** $TARGET  
**Date:** $(date)  
**Tester:** Automated Script  

## Executive Summary
This report contains the results of an automated penetration test performed against the target website.

---

EOF
}

# Log function
log_to_report() {
    echo -e "$1" >> "$REPORT_FILE"
    echo -e "$1"
}

# Extract domain from URL
extract_domain() {
    echo "$1" | sed -E 's/^https?:\/\///' | sed -E 's/\/.*$//' | sed -E 's/:.*$//'
}

# Information Gathering
info_gathering() {
    echo -e "${BLUE}[PHASE 1] Information Gathering${NC}"
    log_to_report "\n## 1. Information Gathering\n"
    
    local domain=$(extract_domain "$TARGET")
    
    # DNS Information
    echo -e "${YELLOW}[1.1] DNS Information${NC}"
    log_to_report "### 1.1 DNS Information\n"
    log_to_report '```'
    
    if command -v dig &> /dev/null; then
        dig "$domain" | tee -a "$OUTPUT_DIR/dns_info.txt" | while read line; do
            log_to_report "$line"
        done
    elif command -v nslookup &> /dev/null; then
        echo "Using nslookup as dig alternative..."
        nslookup "$domain" | tee "$OUTPUT_DIR/dns_info.txt" | while read line; do
            log_to_report "$line"
        done
    elif command -v host &> /dev/null; then
        echo "Using host as dig alternative..."
        host "$domain" | tee "$OUTPUT_DIR/dns_info.txt" | while read line; do
            log_to_report "$line"
        done
    else
        echo "No DNS lookup tools available, using basic ping test..."
        ping -c 2 "$domain" 2>&1 | tee "$OUTPUT_DIR/dns_info.txt" | while read line; do
            log_to_report "$line"
        done
    fi
    log_to_report '```\n'
    
    # WHOIS Information
    echo -e "${YELLOW}[1.2] WHOIS Information${NC}"
    log_to_report "### 1.2 WHOIS Information\n"
    log_to_report '```'
    
    if command -v whois &> /dev/null; then
        whois "$domain" | tee "$OUTPUT_DIR/whois_info.txt" | head -20 | while read line; do
            log_to_report "$line"
        done
    else
        echo "WHOIS not available, trying online lookup..."
        curl -s "http://whois.arin.net/rest/ip/$domain" | head -20 | tee "$OUTPUT_DIR/whois_info.txt" | while read line; do
            log_to_report "$line"
        done 2>/dev/null || log_to_report "WHOIS lookup not available"
    fi
    log_to_report '```\n'
    
    # HTTP Headers
    echo -e "${YELLOW}[1.3] HTTP Headers${NC}"
    log_to_report "### 1.3 HTTP Headers\n"
    log_to_report '```'
    curl -I "$TARGET" 2>/dev/null | tee "$OUTPUT_DIR/http_headers.txt" | while read line; do
        log_to_report "$line"
    done
    log_to_report '```\n'
    
    # Robots.txt
    echo -e "${YELLOW}[1.4] Robots.txt${NC}"
    log_to_report "### 1.4 Robots.txt\n"
    log_to_report '```'
    curl -s "${TARGET}/robots.txt" | tee "$OUTPUT_DIR/robots.txt" | head -20 | while read line; do
        log_to_report "$line"
    done
    log_to_report '```\n'
}

# Port Scanning
port_scanning() {
    echo -e "${BLUE}[PHASE 2] Port Scanning${NC}"
    log_to_report "## 2. Port Scanning\n"
    
    local domain=$(extract_domain "$TARGET")
    
    if command -v nmap &> /dev/null; then
        echo -e "${YELLOW}[2.1] Nmap Scan${NC}"
        log_to_report "### 2.1 Port Scan Results\n"
        log_to_report '```'
        
        # Quick scan of common ports
        timeout 300 nmap -sS -O -sV --top-ports 1000 "$domain" | tee "$OUTPUT_DIR/nmap_scan.txt" | while read line; do
            log_to_report "$line"
        done
        log_to_report '```\n'
        
        # Service detection
        echo -e "${YELLOW}[2.2] Service Detection${NC}"
        log_to_report "### 2.2 Service Detection\n"
        log_to_report '```'
        timeout 300 nmap -sV -A "$domain" | tee "$OUTPUT_DIR/service_detection.txt" | while read line; do
            log_to_report "$line"
        done
        log_to_report '```\n'
        
    else
        echo -e "${YELLOW}[2.1] Manual Port Check (nmap not available)${NC}"
        log_to_report "### 2.1 Manual Port Check\n"
        log_to_report '```'
        
        # Manual port checking with netcat/telnet
        manual_port_scan "$domain"
        
        log_to_report '```\n'
    fi
}

# Manual port scanning when nmap is not available
manual_port_scan() {
    local target="$1"
    local common_ports=(21 22 23 25 53 80 110 143 443 993 995 8080 8443)
    
    echo "Manual port scanning for $target..."
    log_to_report "Manual port scanning for $target..."
    
    for port in "${common_ports[@]}"; do
        if command -v nc &> /dev/null; then
            # Using netcat
            if timeout 3 nc -z "$target" "$port" 2>/dev/null; then
                log_to_report "$port/tcp open"
                echo "Port $port: Open"
            fi
        elif command -v telnet &> /dev/null; then
            # Using telnet as fallback
            if echo | timeout 3 telnet "$target" "$port" 2>&1 | grep -q "Connected"; then
                log_to_report "$port/tcp open"
                echo "Port $port: Open"
            fi
        else
            # Using curl for HTTP ports
            case $port in
                80|8080)
                    if curl -s --connect-timeout 3 "http://$target:$port" >/dev/null 2>&1; then
                        log_to_report "$port/tcp open (HTTP)"
                        echo "Port $port: Open (HTTP)"
                    fi
                    ;;
                443|8443)
                    if curl -s --connect-timeout 3 "https://$target:$port" >/dev/null 2>&1; then
                        log_to_report "$port/tcp open (HTTPS)"
                        echo "Port $port: Open (HTTPS)"
                    fi
                    ;;
            esac
        fi
        sleep 0.1  # Rate limiting
    done
}

# Directory Enumeration
directory_enumeration() {
    echo -e "${BLUE}[PHASE 3] Directory Enumeration${NC}"
    log_to_report "## 3. Directory Enumeration\n"
    
    echo -e "${YELLOW}[3.1] Directory Discovery${NC}"
    log_to_report "### 3.1 Directory Discovery\n"
    log_to_report '```'
    
    # Try different tools in order of preference
    if command -v gobuster &> /dev/null; then
        echo "Using gobuster..."
        timeout 300 gobuster dir -u "$TARGET" -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -t 20 2>/dev/null | head -30 | while read line; do
            log_to_report "$line"
        done
    elif command -v dirb &> /dev/null; then
        echo "Using dirb..."
        timeout 300 dirb "$TARGET" -r -S 2>/dev/null | head -30 | while read line; do
            log_to_report "$line"
        done
    elif [[ -d "$SCRIPT_DIR/dirsearch" ]]; then
        echo "Using dirsearch..."
        cd "$SCRIPT_DIR/dirsearch"
        timeout 300 python3 dirsearch.py -u "$TARGET" -e php,html,js,txt --simple-report="$OUTPUT_DIR/dirsearch_results.txt" 2>/dev/null | head -30 | while read line; do
            log_to_report "$line"
        done
        cd "$SCRIPT_DIR"
    else
        echo "No directory enumeration tools available, performing manual checks..."
        manual_directory_check
    fi
    
    log_to_report '```\n'
    
    # Common files check
    echo -e "${YELLOW}[3.2] Common Files Check${NC}"
    log_to_report "### 3.2 Common Files\n"
    
    local common_files=("admin" "login" "dashboard" "config" "backup" "test" "dev" "api" "wp-admin" "phpmyadmin")
    
    for file in "${common_files[@]}"; do
        response=$(curl -s -o /dev/null -w "%{http_code}" "${TARGET}/${file}" --max-time 10)
        if [ "$response" != "404" ]; then
            log_to_report "- /${file} - Status: $response"
        fi
        sleep 0.1  # Rate limiting
    done
    log_to_report "\n"
}

# Manual directory check when tools are not available
manual_directory_check() {
    log_to_report "### Manual Directory Check\n"
    
    local common_dirs=("admin" "login" "dashboard" "api" "test" "dev" "backup" "config" "uploads" "images" "js" "css" "includes" "wp-admin" "wp-content" "phpmyadmin" "database")
    
    for dir in "${common_dirs[@]}"; do
        response=$(curl -s -o /dev/null -w "%{http_code}" "${TARGET}/${dir}" --max-time 5)
        if [[ "$response" =~ ^[23] ]]; then
            log_to_report "âœ… Found: /${dir} - Status: $response"
        elif [ "$response" != "404" ]; then
            log_to_report "âš ï¸  Interesting: /${dir} - Status: $response"
        fi
        sleep 0.1  # Rate limiting
    done
}

# Vulnerability Assessment
vulnerability_assessment() {
    echo -e "${BLUE}[PHASE 4] Vulnerability Assessment${NC}"
    log_to_report "## 4. Vulnerability Assessment\n"
    
    # Initialize vulnerability counter
    local high_vulns=0
    local medium_vulns=0
    local low_vulns=0
    local cve_list=()
    
    # Nikto scan (if available)
    if command -v nikto &> /dev/null; then
        echo -e "${YELLOW}[4.1] Nikto Vulnerability Scan${NC}"
        log_to_report "### 4.1 Nikto Results\n"
        log_to_report '```'
        timeout 300 nikto -h "$TARGET" -Format txt 2>/dev/null | tee "$OUTPUT_DIR/nikto_full.txt" | head -40 | while read line; do
            log_to_report "$line"
        done
        log_to_report '```\n'
        
        # Parse nikto results for CVEs
        parse_nikto_cves "$OUTPUT_DIR/nikto_full.txt"
    else
        echo -e "${YELLOW}[4.1] Nikto not available, performing manual vulnerability checks${NC}"
        manual_vuln_check
    fi
    
    # SSL/TLS Vulnerability Assessment
    echo -e "${YELLOW}[4.2] SSL/TLS Vulnerability Assessment${NC}"
    log_to_report "### 4.2 SSL/TLS Security Analysis\n"
    ssl_vulnerability_check
    
    # Web Application Vulnerability Testing
    echo -e "${YELLOW}[4.3] Web Application Vulnerability Testing${NC}"
    log_to_report "### 4.3 Web Application Security Assessment\n"
    web_app_vuln_check
    
    # Server Vulnerability Assessment
    echo -e "${YELLOW}[4.4] Server Vulnerability Assessment${NC}"
    log_to_report "### 4.4 Server Security Analysis\n"
    server_vuln_check
    
    # CVE Summary Report
    echo -e "${YELLOW}[4.5] CVE Summary${NC}"
    log_to_report "### 4.5 CVE (Common Vulnerabilities and Exposures) Summary\n"
    generate_cve_summary
}

# Parse Nikto results for CVE information
parse_nikto_cves() {
    local nikto_file="$1"
    if [[ -f "$nikto_file" ]]; then
        echo "Parsing Nikto results for CVE information..."
        grep -i "cve-" "$nikto_file" | while read line; do
            cve=$(echo "$line" | grep -oE "CVE-[0-9]{4}-[0-9]+")
            if [[ -n "$cve" ]]; then
                echo "Found CVE: $cve" >> "$OUTPUT_DIR/cve_list.txt"
            fi
        done
    fi
}

# SSL/TLS Vulnerability Check
ssl_vulnerability_check() {
    local domain=$(extract_domain "$TARGET")
    
    # Check SSL certificate
    log_to_report "#### SSL Certificate Analysis:\n"
    log_to_report '```'
    
    if echo | timeout 10 openssl s_client -connect "${domain}:443" -servername "$domain" 2>/dev/null | openssl x509 -noout -text > "$OUTPUT_DIR/ssl_cert.txt" 2>/dev/null; then
        
        # Check certificate validity
        cert_info=$(cat "$OUTPUT_DIR/ssl_cert.txt")
        log_to_report "$cert_info" | head -20
        
        # Check for weak algorithms
        if echo "$cert_info" | grep -qi "md5\|sha1"; then
            log_to_report "\nâš ï¸  **MEDIUM RISK**: Weak signature algorithm detected"
            ((medium_vulns++))
        fi
        
        # Check certificate expiration
        expiry=$(echo | openssl s_client -connect "${domain}:443" -servername "$domain" 2>/dev/null | openssl x509 -noout -dates | grep "notAfter")
        log_to_report "\nCertificate Expiry: $expiry"
        
        # SSL/TLS Protocol Testing
        log_to_report "\n#### SSL/TLS Protocol Testing:\n"
        
        # Test for SSLv3 (should be disabled)
        if echo | timeout 5 openssl s_client -connect "${domain}:443" -ssl3 2>/dev/null | grep -q "BEGIN CERTIFICATE"; then
            log_to_report "âš ï¸  **HIGH RISK**: SSLv3 enabled - CVE-2014-3566 (POODLE)"
            ((high_vulns++))
            echo "CVE-2014-3566" >> "$OUTPUT_DIR/cve_list.txt"
        else
            log_to_report "âœ… SSLv3 disabled"
        fi
        
        # Test for TLSv1.0 (should be disabled)
        if echo | timeout 5 openssl s_client -connect "${domain}:443" -tls1 2>/dev/null | grep -q "BEGIN CERTIFICATE"; then
            log_to_report "âš ï¸  **MEDIUM RISK**: TLSv1.0 enabled - CVE-2011-3389 (BEAST)"
            ((medium_vulns++))
            echo "CVE-2011-3389" >> "$OUTPUT_DIR/cve_list.txt"
        else
            log_to_report "âœ… TLSv1.0 disabled"
        fi
        
    else
        log_to_report "SSL certificate check failed or not HTTPS"
    fi
    log_to_report '```\n'
}

# Web Application Vulnerability Check
web_app_vuln_check() {
    local target_responses="$OUTPUT_DIR/vuln_responses"
    mkdir -p "$target_responses"
    
    log_to_report "#### Cross-Site Scripting (XSS) Testing:\n"
    
    # XSS Payloads
    local xss_payloads=(
        "<script>alert('XSS')</script>"
        "'><script>alert('XSS')</script>"
        "\"><script>alert('XSS')</script>"
        "javascript:alert('XSS')"
        "<img src=x onerror=alert('XSS')>"
    )
    
    local xss_found=false
    for payload in "${xss_payloads[@]}"; do
        response_file="${target_responses}/xss_test_$(date +%s).html"
        curl -s -d "test=${payload}" "$TARGET" -o "$response_file" --max-time 10 2>/dev/null
        
        if grep -qi "alert('XSS')" "$response_file" 2>/dev/null; then
            log_to_report "âš ï¸  **HIGH RISK**: Reflected XSS vulnerability detected with payload: \`${payload}\`\n"
            log_to_report "**Exploitation**: This can be used to steal cookies, session tokens, or perform actions on behalf of users.\n"
            ((high_vulns++))
            xss_found=true
        fi
    done
    
    if [ "$xss_found" = false ]; then
        log_to_report "âœ… No obvious XSS vulnerabilities found in basic testing\n"
    fi
    
    log_to_report "#### SQL Injection Testing:\n"
    
    # SQL Injection Payloads
    local sql_payloads=(
        "' OR '1'='1"
        "' OR 1=1--"
        "'; DROP TABLE users;--"
        "' UNION SELECT NULL--"
        "1' AND 1=1--"
    )
    
    local sql_found=false
    for payload in "${sql_payloads[@]}"; do
        response=$(curl -s -w "%{http_code}" -d "test=${payload}" "$TARGET" -o /dev/null --max-time 10 2>/dev/null)
        error_response=$(curl -s -d "test=${payload}" "$TARGET" --max-time 10 2>/dev/null)
        
        # Check for SQL error messages
        if echo "$error_response" | grep -qi "sql\|mysql\|oracle\|postgresql\|sqlite\|syntax error\|odbc"; then
            log_to_report "âš ï¸  **HIGH RISK**: Potential SQL Injection vulnerability detected with payload: \`${payload}\`\n"
            log_to_report "**Exploitation**: This can be used to access, modify, or delete database contents.\n"
            ((high_vulns++))
            sql_found=true
        fi
    done
    
    if [ "$sql_found" = false ]; then
        log_to_report "âœ… No obvious SQL injection vulnerabilities found in basic testing\n"
    fi
    
    log_to_report "#### Local File Inclusion (LFI) Testing:\n"
    
    # LFI Payloads
    local lfi_payloads=(
        "../../../etc/passwd"
        "....//....//....//etc/passwd"
        "/etc/passwd"
        "C:/Windows/System32/drivers/etc/hosts"
    )
    
    local lfi_found=false
    for payload in "${lfi_payloads[@]}"; do
        lfi_response=$(curl -s "${TARGET}?file=${payload}" --max-time 10 2>/dev/null)
        
        if echo "$lfi_response" | grep -qi "root:\|daemon:\|bin:\|sys:"; then
            log_to_report "âš ï¸  **HIGH RISK**: Local File Inclusion vulnerability detected with payload: \`${payload}\`\n"
            log_to_report "**Exploitation**: This can be used to read sensitive files from the server.\n"
            ((high_vulns++))
            lfi_found=true
        fi
    done
    
    if [ "$lfi_found" = false ]; then
        log_to_report "âœ… No obvious LFI vulnerabilities found in basic testing\n"
    fi
}

# Server Vulnerability Check
server_vuln_check() {
    # Server information disclosure
    log_to_report "#### Server Information Disclosure:\n"
    server_header=$(curl -I -s "$TARGET" | grep -i "server:" | head -1)
    powered_by=$(curl -I -s "$TARGET" | grep -i "x-powered-by:" | head -1)
    
    log_to_report "Server: ${server_header:-'Not disclosed'}\n"
    log_to_report "X-Powered-By: ${powered_by:-'Not disclosed'}\n"
    
    # Check for version disclosure
    if echo "$server_header" | grep -qE "[0-9]+\.[0-9]+"; then
        log_to_report "âš ï¸  **LOW RISK**: Server version disclosed in headers\n"
        ((low_vulns++))
    fi
    
    # Check for sensitive files
    log_to_report "#### Sensitive Files Check:\n"
    local sensitive_files=(
        ".env" 
        ".git/config" 
        "config.php" 
        "wp-config.php" 
        "database.sql" 
        ".htaccess" 
        "composer.json" 
        "package.json"
        "phpinfo.php"
        "test.php"
        "backup.sql"
        "dump.sql"
    )
    
    for file in "${sensitive_files[@]}"; do
        response=$(curl -s -o /dev/null -w "%{http_code}" "${TARGET}/${file}" --max-time 5)
        if [[ "$response" =~ ^[23] ]]; then
            log_to_report "âš ï¸  **MEDIUM-HIGH RISK**: Sensitive file accessible: /${file} (Status: $response)\n"
            log_to_report "**Exploitation**: This file may contain sensitive information or configuration details.\n"
            ((medium_vulns++))
        fi
        sleep 0.1
    done
    
    # HTTP Methods Check
    log_to_report "#### HTTP Methods Testing:\n"
    methods=("OPTIONS" "TRACE" "PUT" "DELETE" "PATCH" "HEAD")
    for method in "${methods[@]}"; do
        response=$(curl -s -X "$method" -w "%{http_code}" -o /dev/null "$TARGET" --max-time 5 2>/dev/null)
        if [[ "$response" =~ ^[23] ]] && [[ "$method" != "HEAD" ]]; then
            case $method in
                "TRACE")
                    log_to_report "âš ï¸  **MEDIUM RISK**: HTTP TRACE method enabled - CVE-2003-1567 (XST)\n"
                    ((medium_vulns++))
                    echo "CVE-2003-1567" >> "$OUTPUT_DIR/cve_list.txt"
                    ;;
                "PUT"|"DELETE")
                    log_to_report "âš ï¸  **HIGH RISK**: HTTP $method method enabled\n"
                    log_to_report "**Exploitation**: This may allow unauthorized file upload/deletion.\n"
                    ((high_vulns++))
                    ;;
            esac
        fi
    done
}

# Generate CVE Summary
generate_cve_summary() {
    # Count vulnerabilities
    local total_vulns=$((high_vulns + medium_vulns + low_vulns))
    
    log_to_report "#### Vulnerability Summary:\n"
    log_to_report "- **High Risk**: $high_vulns vulnerabilities\n"
    log_to_report "- **Medium Risk**: $medium_vulns vulnerabilities\n"
    log_to_report "- **Low Risk**: $low_vulns vulnerabilities\n"
    log_to_report "- **Total**: $total_vulns vulnerabilities identified\n\n"
    
    # CVE List
    if [[ -f "$OUTPUT_DIR/cve_list.txt" ]]; then
        log_to_report "#### Identified CVEs:\n"
        sort -u "$OUTPUT_DIR/cve_list.txt" | while read cve; do
            if [[ -n "$cve" ]]; then
                log_to_report "- **$cve**: [Details](https://cve.mitre.org/cgi-bin/cvename.cgi?name=$cve)\n"
            fi
        done
        log_to_report "\n"
    fi
    
    # Risk Assessment
    log_to_report "#### Risk Assessment:\n"
    if [[ $high_vulns -gt 0 ]]; then
        log_to_report "ğŸ”´ **CRITICAL**: Immediate attention required due to high-risk vulnerabilities.\n"
    elif [[ $medium_vulns -gt 3 ]]; then
        log_to_report "ğŸŸ¡ **HIGH**: Multiple medium-risk vulnerabilities require prompt attention.\n"
    elif [[ $medium_vulns -gt 0 ]]; then
        log_to_report "ğŸŸ¡ **MEDIUM**: Some security improvements recommended.\n"
    else
        log_to_report "ğŸŸ¢ **LOW**: Basic security assessment shows minimal risks.\n"
    fi
    
    # Recommendations
    log_to_report "\n#### Immediate Actions Required:\n"
    if [[ $high_vulns -gt 0 ]]; then
        log_to_report "1. **URGENT**: Address high-risk vulnerabilities immediately\n"
        log_to_report "2. Implement input validation and output encoding\n"
        log_to_report "3. Update server software and apply security patches\n"
    fi
    if [[ $medium_vulns -gt 0 ]]; then
        log_to_report "4. Review server configuration and remove sensitive file exposure\n"
        log_to_report "5. Implement security headers (CSP, HSTS, etc.)\n"
    fi
    log_to_report "6. Regular security assessments and penetration testing\n"
    log_to_report "7. Security awareness training for development team\n\n"
}

# Manual vulnerability check when tools are not available
manual_vuln_check() {
    log_to_report "### 4.1 Manual Vulnerability Assessment\n"
    
    # Check common vulnerabilities manually
    log_to_report "#### HTTP Methods Check:\n"
    methods=("OPTIONS" "TRACE" "PUT" "DELETE" "PATCH")
    for method in "${methods[@]}"; do
        response=$(curl -s -X "$method" -w "%{http_code}" -o /dev/null "$TARGET" --max-time 5 2>/dev/null)
        if [[ "$response" =~ ^[23] ]]; then
            log_to_report "âš ï¸  HTTP $method enabled (Status: $response)\n"
        fi
    done
}

# Security Headers Check
security_headers_check() {
    echo -e "${BLUE}[PHASE 5] Security Headers Analysis${NC}"
    log_to_report "## 5. Security Headers Analysis\n"
    
    local headers=$(curl -I -s "$TARGET")
    
    log_to_report "### Security Headers Status:\n"
    
    # Check important security headers
    if echo "$headers" | grep -qi "strict-transport-security"; then
        log_to_report "âœ… HSTS (HTTP Strict Transport Security) - Present\n"
    else
        log_to_report "âŒ HSTS (HTTP Strict Transport Security) - Missing\n"
    fi
    
    if echo "$headers" | grep -qi "x-frame-options"; then
        log_to_report "âœ… X-Frame-Options - Present\n"
    else
        log_to_report "âŒ X-Frame-Options - Missing (Clickjacking vulnerability)\n"
    fi
    
    if echo "$headers" | grep -qi "x-xss-protection"; then
        log_to_report "âœ… X-XSS-Protection - Present\n"
    else
        log_to_report "âŒ X-XSS-Protection - Missing\n"
    fi
    
    if echo "$headers" | grep -qi "x-content-type-options"; then
        log_to_report "âœ… X-Content-Type-Options - Present\n"
    else
        log_to_report "âŒ X-Content-Type-Options - Missing\n"
    fi
    
    if echo "$headers" | grep -qi "content-security-policy"; then
        log_to_report "âœ… Content-Security-Policy - Present\n"
    else
        log_to_report "âŒ Content-Security-Policy - Missing\n"
    fi
}

# Generate final report
generate_final_report() {
    echo -e "${BLUE}[PHASE 6] Generating Final Report${NC}"
    
    log_to_report "## 6. Executive Summary and Risk Assessment\n"
    
    # Risk Assessment Summary
    local total_vulns=0
    local high_risk=0
    local medium_risk=0
    local low_risk=0
    
    # Count vulnerabilities from CVE list and vulnerability assessment
    if [[ -f "$OUTPUT_DIR/cve_list.txt" ]]; then
        total_cves=$(sort -u "$OUTPUT_DIR/cve_list.txt" | wc -l)
    else
        total_cves=0
    fi
    
    log_to_report "### Security Assessment Overview:\n"
    log_to_report "**Target**: $TARGET\n"
    log_to_report "**Assessment Date**: $(date)\n"
    log_to_report "**Duration**: Automated scan\n"
    log_to_report "**Scope**: Web application security assessment\n\n"
    
    log_to_report "### Key Findings:\n"
    
    # Check if any high-risk indicators were found
    if grep -q "HIGH RISK" "$REPORT_FILE" 2>/dev/null; then
        high_risk=$(grep -c "HIGH RISK" "$REPORT_FILE" 2>/dev/null || echo "0")
        log_to_report "ğŸ”´ **Critical Issues Found**: $high_risk high-risk vulnerabilities identified\n"
    fi
    
    if grep -q "MEDIUM RISK" "$REPORT_FILE" 2>/dev/null; then
        medium_risk=$(grep -c "MEDIUM RISK" "$REPORT_FILE" 2>/dev/null || echo "0")
        log_to_report "ğŸŸ¡ **Medium Risk Issues**: $medium_risk medium-risk vulnerabilities identified\n"
    fi
    
    if grep -q "LOW RISK" "$REPORT_FILE" 2>/dev/null; then
        low_risk=$(grep -c "LOW RISK" "$REPORT_FILE" 2>/dev/null || echo "0")
        log_to_report "ğŸŸ¢ **Low Risk Issues**: $low_risk low-risk vulnerabilities identified\n"
    fi
    
    log_to_report "ğŸ“‹ **Total CVEs Identified**: $total_cves\n\n"
    
    # OWASP Top 10 Assessment
    log_to_report "### OWASP Top 10 Assessment:\n"
    
    if grep -q "XSS" "$REPORT_FILE" 2>/dev/null; then
        log_to_report "- **A03:2021 - Injection**: Cross-Site Scripting vulnerabilities detected\n"
    fi
    
    if grep -q "SQL" "$REPORT_FILE" 2>/dev/null; then
        log_to_report "- **A03:2021 - Injection**: SQL Injection vulnerabilities detected\n"
    fi
    
    if grep -q "Sensitive file accessible" "$REPORT_FILE" 2>/dev/null; then
        log_to_report "- **A01:2021 - Broken Access Control**: Sensitive files accessible\n"
    fi
    
    if grep -q "Server version disclosed" "$REPORT_FILE" 2>/dev/null; then
        log_to_report "- **A09:2021 - Security Logging and Monitoring Failures**: Information disclosure\n"
    fi
    
    if ! grep -q "HSTS: Present" "$REPORT_FILE" 2>/dev/null; then
        log_to_report "- **A02:2021 - Cryptographic Failures**: Missing security headers\n"
    fi
    
    log_to_report "\n### Compliance Assessment:\n"
    log_to_report "- **PCI DSS**: $(grep -q "HIGH RISK" "$REPORT_FILE" && echo "Non-compliant due to security issues" || echo "Requires further assessment")\n"
    log_to_report "- **GDPR**: $(grep -q "Sensitive file accessible" "$REPORT_FILE" && echo "Potential data exposure risks" || echo "Basic privacy controls observed")\n"
    log_to_report "- **ISO 27001**: $(grep -q "MEDIUM RISK\|HIGH RISK" "$REPORT_FILE" && echo "Security controls need improvement" || echo "Baseline security measures in place")\n\n"
    
    log_to_report "### Technical Summary:\n"
    log_to_report "- **Scan completed**: $(date)\n"
    log_to_report "- **Total files generated**: $(ls -1 $OUTPUT_DIR | wc -l)\n"
    log_to_report "- **Raw scan data available**: $OUTPUT_DIR\n"
    log_to_report "- **Automated tools used**: $(command -v nmap >/dev/null && echo "nmap, " || "")$(command -v nikto >/dev/null && echo "nikto, " || "")curl, openssl\n\n"
    
    # Priority Recommendations
    log_to_report "### Priority Action Items:\n\n"
    
    if [[ $high_risk -gt 0 ]]; then
        log_to_report "#### ğŸ”´ URGENT (Complete within 24-48 hours):\n"
        log_to_report "1. **Patch Critical Vulnerabilities**: Address all high-risk findings immediately\n"
        log_to_report "2. **Input Validation**: Implement proper input sanitization for XSS/SQLi protection\n"
        log_to_report "3. **Access Controls**: Review and restrict access to sensitive files\n"
        log_to_report "4. **Incident Response**: Check logs for any exploitation attempts\n\n"
    fi
    
    if [[ $medium_risk -gt 0 ]]; then
        log_to_report "#### ğŸŸ¡ HIGH PRIORITY (Complete within 1-2 weeks):\n"
        log_to_report "1. **Security Headers**: Implement comprehensive security headers (HSTS, CSP, etc.)\n"
        log_to_report "2. **Server Hardening**: Update server software and remove version disclosure\n"
        log_to_report "3. **File Permissions**: Review and secure sensitive configuration files\n"
        log_to_report "4. **SSL/TLS**: Upgrade to latest TLS versions and strong cipher suites\n\n"
    fi
    
    log_to_report "#### ğŸŸ¢ MEDIUM PRIORITY (Complete within 1 month):\n"
    log_to_report "1. **Regular Security Scans**: Implement automated vulnerability scanning\n"
    log_to_report "2. **Security Training**: Provide security awareness training to development team\n"
    log_to_report "3. **Code Review**: Implement secure code review processes\n"
    log_to_report "4. **Monitoring**: Set up security monitoring and alerting\n\n"
    
    # Tools and Resources
    log_to_report "### Recommended Tools and Resources:\n"
    log_to_report "- **Vulnerability Management**: OpenVAS, Nessus, or Qualys VMDR\n"
    log_to_report "- **Web Application Scanning**: OWASP ZAP, Burp Suite Professional\n"
    log_to_report "- **Code Analysis**: SonarQube, Checkmarx, or Veracode\n"
    log_to_report "- **Security Headers Testing**: Mozilla Observatory, SecurityHeaders.com\n"
    log_to_report "- **SSL Testing**: SSL Labs SSL Test, testssl.sh\n\n"
    
    # CVE Database Links
    if [[ -f "$OUTPUT_DIR/cve_list.txt" ]] && [[ -s "$OUTPUT_DIR/cve_list.txt" ]]; then
        log_to_report "### CVE Database References:\n"
        log_to_report "For detailed information about identified CVEs, visit:\n"
        log_to_report "- **MITRE CVE Database**: https://cve.mitre.org/\n"
        log_to_report "- **National Vulnerability Database**: https://nvd.nist.gov/\n"
        log_to_report "- **CVE Details**: https://www.cvedetails.com/\n\n"
    fi
    
    log_to_report "### Files Generated:\n"
    for file in "$OUTPUT_DIR"/*; do
        if [ -f "$file" ]; then
            local filesize=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "unknown")
            log_to_report "- $(basename "$file") (${filesize} bytes)\n"
        fi
    done
    
    log_to_report "\n---\n"
    log_to_report "*This report was generated by Automated Pentest Script v1.1*\n"
    log_to_report "*For questions about this assessment, please contact the security team*\n"
    log_to_report "*Next recommended assessment: 30-90 days or after major application changes*\n"
    
    echo -e "${GREEN}[SUCCESS] Comprehensive security report generated: $REPORT_FILE${NC}"
    
    # Generate quick summary for terminal output
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘                    SCAN SUMMARY                              â•‘${NC}"
    echo -e "${BLUE}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
    echo -e "${BLUE}â•‘${NC} High Risk Vulnerabilities: ${RED}$high_risk${NC}$(printf "%*s" $((33-${#high_risk})) "")${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} Medium Risk Vulnerabilities: ${YELLOW}$medium_risk${NC}$(printf "%*s" $((31-${#medium_risk})) "")${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} Low Risk Vulnerabilities: ${GREEN}$low_risk${NC}$(printf "%*s" $((33-${#low_risk})) "")${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•‘${NC} Total CVEs Identified: $total_cves$(printf "%*s" $((37-${#total_cves})) "")${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

# Main function
main() {
    show_banner
    
    # Check and activate virtual environment
    check_venv
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--target)
                TARGET="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Validate target
    if [ -z "$TARGET" ]; then
        echo -e "${RED}[ERROR] Target URL is required${NC}"
        show_help
        exit 1
    fi
    
    # Check dependencies
    check_dependencies
    
    # Initialize output
    init_output "$OUTPUT_DIR"
    
    echo -e "${GREEN}[INFO] Starting penetration test for: $TARGET${NC}"
    echo -e "${YELLOW}[INFO] This may take 10-20 minutes depending on target response${NC}"
    
    # Execute phases with error handling
    set +e  # Don't exit on errors, continue with other phases
    trap 'echo -e "${RED}[WARNING] Script interrupted. Partial results saved in $OUTPUT_DIR${NC}"' INT TERM
    
    info_gathering
    port_scanning
    directory_enumeration
    vulnerability_assessment
    security_headers_check
    generate_final_report
    
    echo -e "${GREEN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    SCAN COMPLETED!                           â•‘"
    echo "â•‘                                                              â•‘"
    echo "â•‘  Report: $REPORT_FILE"
    echo "â•‘  Output: $OUTPUT_DIR"
    echo "â•‘                                                              â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Run main function with all arguments
main "$@"
